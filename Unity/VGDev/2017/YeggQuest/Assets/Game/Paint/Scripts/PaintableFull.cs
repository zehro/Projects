using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

// PaintableFull is a texture-based implementation of an object being Paintable. When a PaintableFull receives Paint(),
// it adds a splotch of paint of the given color at the given position on this object, based on the lightmap coordinates.
// This is good for large meshes (like floors and walls) which need to respond to paint like detailed, dynamic canvases.
// In general, this implementation should be used sparingly, and ONLY on static objects (most likely large ones.) It
// does NOT support the color-only PaintRequest, because raycast information is necessary for the texturing behavior.

namespace YeggQuest.NS_Paint
{
    [RequireComponent(typeof(MeshRenderer))]
    public class PaintableFull : Paintable
    {
        public int textureSize = 256;       // How large the texture for this object's paint information is
        public int radius = 4;              // How large the brush radius is when this object is painted on

        private Material mat;               // The procedural material generated by this script
        private Texture2D texture;          // The texture that holds the paint information for this object

        private int scaleID;                // shader uniform ID for the world scale

        void Start()
        {
            mat = InitializeMaterial(GetComponent<MeshRenderer>(), "PaintableFull");

            texture = new Texture2D(textureSize, textureSize);
            ApplySolidColor(PaintColor.Clear);
            mat.SetTexture("_PaintTex", texture);

            scaleID = Shader.PropertyToID("_Scale");
        }

        void Update()
        {
            mat.SetVector(scaleID, transform.localScale);
        }

        void OnDestroy()
        {
            if (mat)
                Destroy(mat);
        }

        // ======================================================================================================================== MESSAGES

        // PaintableFull responds to paint requests by painting on a texture at the position indicated by
        // the PaintRequest's raycast. The texture painting is done like a soft Photoshop brush (e.g. like
        // Blend SrcAlpha OneMinusSrcAlpha) to match conventional transparency / repainting behavior. Pixels
        // can turn intermediate colors if half-painted by multiple core paint colors. If there is no raycast,
        // this implementation can't function properly, so just return false.

        public override bool Paint(PaintRequest request)
        {
            if (request.useRaycast == false)
                return false;

            // Otherwise, paint on the texture like normal

            int x = (int)(request.raycast.lightmapCoord.x * textureSize);
            int y = (int)(request.raycast.lightmapCoord.y * textureSize);
            
            Color c = PaintColors.ToColor(request.color);

            for (int a = -radius; a <= radius; a++)
            {
                for (int b = -radius; b <= radius; b++)
                {
                    // The source is the brush being used (at x and y, with radius, strength, and color)

                    float srcAlpha = request.strength * (1 - Mathf.Clamp01(Mathf.Sqrt(a * a + b * b) / radius));
                    Color src = c * new Vector4(1, 1, 1, srcAlpha);

                    // The destination is the existing paint texture

                    Color dest = texture.GetPixel(x + a, y + b);
                    float destAlpha = dest.a;

                    // Set the canvas (Blend SrcAlpha OneMinusSrcAlpha)

                    float outAlpha = srcAlpha + destAlpha * (1 - srcAlpha);
                    Color outColor = Color.Lerp(src, dest, 1 - srcAlpha);
                    outColor.a = outAlpha;

                    texture.SetPixel(x + a, y + b, outColor);
                }
            }

            texture.Apply();

            return true;
        }

        // ======================================================================================================================== HELPERS

        // A private helper function which changes every pixel on the
        // procedural texture to be the PaintColor that's passed in.

        private void ApplySolidColor(PaintColor color)
        {
            texture.SetPixels(Enumerable.Repeat(PaintColors.ToColor(color), textureSize * textureSize).ToArray());
            texture.Apply();
        }
    }
}