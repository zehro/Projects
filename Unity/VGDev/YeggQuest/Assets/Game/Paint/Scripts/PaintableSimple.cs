using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

// PaintableSimple is a discrete implementation of an object being Paintable. When a PaintableSimple receives Paint(),
// the ENTIRE object becomes the given color as a discrete "state" (after a transition animation.) PaintableSimples
// are thus queriable for the color they are currently retaining, suitable for buttons or other objects which must
// be painted single colors as gameplay mechanics. In general, this implementation should be used on small, dynamic objects.

namespace YeggQuest.NS_Paint
{
    [RequireComponent(typeof(MeshFilter))]
    [RequireComponent(typeof(MeshRenderer))]
    public class PaintableSimple : Paintable
    {
        public float effectWorldSize = 1;   // How wide the paint animation front looks in world space
        public float effectWorldSpeed = 5;  // How quickly the paint animation front moves in world space

        private MeshFilter filter;          // The mesh filter attached to this object
        private Material mat;               // The procedural material generated by this script
        private PaintColor color;           // The current color painted on this object (clear at start)

        private int scaleID;                // shader uniform ID for the world scale
        private int colorID;                // shader uniform ID for the current paint color
        private int colorPrevID;            // shader uniform ID for the previous paint color
        private int localPointID;           // shader uniform ID for the point where paint originates
        private int localRadiusID;          // shader uniform ID for the radius of the paint animation
        private int effectSizeID;           // shader uniform ID for the width of the paint animation glow

        void Start()
        {
            filter = GetComponent<MeshFilter>();
            mat = InitializeMaterial(GetComponent<MeshRenderer>(), "PaintableSimple");

            scaleID = Shader.PropertyToID("_Scale");
            colorID = Shader.PropertyToID("_Color");
            colorPrevID = Shader.PropertyToID("_ColorPrev");
            localPointID = Shader.PropertyToID("_LocalPoint");
            localRadiusID = Shader.PropertyToID("_LocalRadius");
            effectSizeID = Shader.PropertyToID("_EffectSize");
        }

        void Update()
        {
            mat.SetVector(scaleID, transform.localScale);
        }

        void OnDestroy()
        {
            if (mat)
                Destroy(mat);
        }

        // ======================================================================================================================== MESSAGES

        // PaintableSimple responds to paint requests discretely, by playing a coroutine animation that turns
        // the entire object the given color over a brief period of time. The animation has a world origin, and is
        // generally set to the world point of the PaintRequest's raycast if one is provided. However, if there
        // is none, it simply uses the object's origin as a fallback. Also note that a PaintableSimple which is
        // already the given PaintColor will simply do nothing, returning "false" to signify failure / no change.

        public override bool Paint(PaintRequest request)
        {
            if (color == request.color)
                return false;

            StopAllCoroutines();
            StartCoroutine(PaintRoutine(request.useRaycast ? request.raycast.point : transform.position, request.color));
            return true;
        }

        // ======================================================================================================================== GETTERS

        // Returns whether this object is painted the given PaintColor. Useful for discrete queries about color
        // ("did you paint my house red?" / "is the button blue?") which must be used for gameplay logic.

        public bool IsPainted(PaintColor color)
        {
            return (this.color == color);
        }

        // ======================================================================================================================== HELPERS

        // A private coroutine which does the repainting animation. Given a world-space origin and a paint color,
        // a sphere of the paint color expands onto this object for the duration of this coroutine and eventually
        // completely fills it with the new color.

        private IEnumerator PaintRoutine(Vector3 worldPoint, PaintColor color)
        {
            // At the beginning of the animation, set the material's uniforms for the
            // previous color, the current color, and the local point to the given data

            mat.SetColor(colorPrevID, PaintColors.ToColor(this.color));
            mat.SetColor(colorID, PaintColors.ToColor(this.color = color));
            Vector3 localPoint = transform.InverseTransformPoint(worldPoint);
            localPoint.x *= transform.localScale.x;
            localPoint.y *= transform.localScale.y;
            localPoint.z *= transform.localScale.z;
            mat.SetVector(localPointID, localPoint);

            // Figure out the distance to the furthest corner on the AABB of the renderer.
            // This is the maximum radius that the transition will fill to (plus the effect size.)

            float maxRadius = 0;

            for (int x = -1; x <= 1; x += 2)
            {
                for (int y = -1; y <= 1; y += 2)
                {
                    for (int z = -1; z <= 1; z += 2)
                    {
                        Vector3 corner = filter.mesh.bounds.extents;
                        corner.Scale(transform.localScale);
                        corner.Scale(new Vector3(x, y, z));
                        maxRadius = Mathf.Max(maxRadius, Vector3.Distance(localPoint, corner));
                    }
                }
            }

            maxRadius += effectWorldSize;

            // Play the animation. It takes as long as the maximum radius divided by the speed.

            mat.SetFloat(localRadiusID, 0);
            mat.SetFloat(effectSizeID, 0);

            float paintTime = maxRadius / effectWorldSpeed;
            for (float f = 0; f < paintTime; f += Time.deltaTime)
            {
                float t = f / paintTime;
                mat.SetFloat(localRadiusID, t * maxRadius);
                mat.SetFloat(effectSizeID, Mathf.Pow(4 * t * (1 - t), 0.5f) * effectWorldSize);
                yield return null;
            }

            mat.SetFloat(localRadiusID, maxRadius);
            mat.SetFloat(effectSizeID, 0);
        }
    }
}